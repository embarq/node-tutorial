{
  "name": "Nanboard",
  "tagline": "Building simple RESTful API using Node.js, Express and MongodDB",
  "body": "\r\n# Разработка RESTful API на Node.js\r\n## Foreword\r\nИтак, цель данного практикума - разработка RESTful API в среде Node.js.\r\nПосмотрим, что же говорят о Node.js на [википедии](https://ru.wikipedia.org/wiki/Node.js):\r\n\r\n> **Node** или **Node.js** - программная платформа, основанная на движке **V8** (транслирующем JavaScript в машинный код), превращающая JavaScript из узкоспециализированного языка в язык общего назначения\r\n\r\nНу в общем-то так - **Node.js** - программная платформа, основанная на движке **Javascript V8**. Она позволит нам выполнять Javascript код на сервере.\r\n\r\nКак же  **Node** превращает наш старый-добрый, клиентский JS в язык общего назначения?\r\n\r\n - Набор встроенных стандартных библиотек портированных из `C-lang`\r\n - Пакетный менеджер **NPM** \r\n - Кроссплатформенность \r\n\r\nВстроенные библиотеки **Node** дают отправную точку для построения чего угодно - на базе платформы **Node** разрабатываются сервисы от ПО умных домов и программирования дронов до высоко-нагруженных серверов с *10к+* одновременных подключений.\r\n\r\n> **NPM** - Встроенный пакентый менеджер, который позволяет вам использовать инструменты сторонних разработчиков, типа [`babel`](https://www.npmjs.com/package/babel), [`lodash`](https://www.npmjs.com/package/lodash) или тот-же [`jquery`](https://www.npmjs.com/package/jquery) при разработке своих приложений или публиковать свои. Стоит помнить, что **сторонние библиотеки и фреймворки не будут работать в браузере если они подключаются с помощью ф-ции `require`** .\r\n\r\n> [**REST**](https://habrahabr.ru/post/38730/)(Representational state transfer) - Это стиль архитектуры программного обеспечения для распределенных систем, таких как World Wide Web, который, как правило, используется для построения веб-служб. Термин REST был введен в 2000 году Роем Филдингом, одним из авторов HTTP-протокола. Системы, поддерживающие REST, называются RESTful-системами.\r\n\r\n## План практикума\r\n\r\n 1. ТЗ\r\n 2. Выбор инструментов\r\n 4. Настройка окружения и рабочей среды\r\n 5. Немного серверного-кода\r\n\r\n## ТЗ\r\nНам дано такое **техническое задание**: нужно разработать RESTful API - Новостной сервис/агрегатор по шаблону проектирования [**MVC**](https://ru.wikipedia.org/wiki/Model-View-Controller) на базе платформы **Node.js** и данных  [**The Guardian**](https://www.theguardian.com/)\r\n\r\n## Выбор инструментов\r\n### Сервер\r\nОсновой нашего сервиса будет веб-фреймворк - [`epxress.js`](http://expressjs.com/ru/):\r\n\r\n> Express\r\n> : это минималистичный и гибкий веб-фреймворк для приложений Node.js, предоставляющий обширный набор функций для мобильных и веб-приложений. Имея в своем распоряжении множество служебных методов HTTP и промежуточных обработчиков, создать надежный API можно быстро и легко. Express предоставляет тонкий слой фундаментальных функций веб-приложений, которые не мешают вам работать с давно знакомыми и любимыми вами функциями Node.js\r\n\r\nВ нашем же случае, **Express** позволяет легко и быстро *поднять*  API-сервис.\r\n\r\nДополнительные инструменты:\r\n\r\n - [`async`](https://www.npmjs.com/package/async) - инструмент который позволяет немного упростить и привести ваш асинхронный код к более красивому и читаемому виду\r\n - [`http`](https://nodejs.org/api/http.html)/[`https`](https://nodejs.org/api/https.html) - стандартный http-модуль, который поставляется вместе с Node.js\r\n\r\n### База данных и модель данных\r\nВ роли базы данных будем использовать [**MongoDB**](https://www.mongodb.com):\r\n\r\n> **MongoDB**\r\n> : (от англ. *humongous — огромный*) — документоориентированная система управления базами данных (СУБД) с открытым исходным кодом, не требующая описания схемы таблиц. Написана на языке `C++`\r\n\r\nВыбор **MongoDB** в роли основной базы данных обоснован высокой производительностью СУБД и легкостью в манипуляции данными, а так-же то, что ТЗ соответствует основному use-case'у для данной СУБД, а именно - хранение и управление данными с неявной структурой.\r\n\r\nВ качестве менеджера моделей данных будем использовать [`mongoose`](http://mongoosejs.com/) - обертку, позволяющую создавать удобные и функциональные схемы документов.\r\n \r\n## Настройка окружения и рабочей среды\r\nПлан ~~побега~~ действий таков:\r\n\r\n 1. Создание структуры рабочей директории \r\n 2. Установка и настройка Node.js, NPM и MongoDB\r\n 3. Инициализация проекта и установка зависимостей\r\n 5. Конфигурирование MongoDB для проекта\r\n\r\n### Создание структуры рабочей директории \r\n```\r\nproject-root/\r\n\t`-- etc/\t\t\t\t\t-> configs, logs\r\n\t`-- node_modules/\t\t\t-> npm packages\r\n\t\t`-- async/\r\n\t\t`-- express/\r\n\t\t`-- ...\r\n\t`-- public/\t\t\t\t\t-> client-side statics\r\n\t\t`-- templates/\t\t\t-> client-side templates\r\n\t\t`-- vendor/\t\t\t\t-> client-side packages\r\n\t\t\t`-- bootstrap/\r\n\t\t\t`-- bootswatch/\r\n\t\t\t`-- ...\r\n\t`-- server/\t\t\t\t\t-> server-side logic\r\n\t\t`-- controllers/\t\t-> server-side controllers\r\n\t\t`-- lib/\t\t\t\t-> self-written libs\r\n\t\t`-- models/\t\t\t\t-> server-side models\r\n\t\t`-- routes/\t\t\t\t-> api routes\r\n\t\t`-- views/\t\t\t\t-> server-side templates\r\n\t\t\t`-- layouts/\t\t-> server-side layouts\r\n```\r\nПапка `node_modules/` генерируются автоматически - **создавать её вручную не нужно**, и изменять без должного понимания не рекомендуется\r\n\r\n### Установка и настройка Node.js, NPM и MongoDB\r\n\r\n - [Установка Node.js(Brad Traversy)](https://www.youtube.com/watch?v=tlntE8fe6u4)\r\n - [Установка MongoDB по версии METANIT](http://metanit.com/nosql/mongodb/1.2.php)\r\n\r\n### Инициализация проекта и установка зависимостей\r\nПриступим к инициализации проекта. Для того чтобы иметь возможность устанавливать `npm` и `bower` модули нужно для этого инициализировать соответствующие конфигурации проектов.\r\nДля `npm` это:\r\n\r\n```bash\r\n$ npm init\r\n```\r\nили:\r\n\r\n```bash\r\n$ npm init -y\r\n```\r\n\r\n![enter image description here](https://snag.gy/ByTLia.jpg)\r\n\r\nРазница между ними только в том, что `npm init` с флагом `-y` инициализирует проект с указанием полей конфигурационного файла по-умолчанию, а в первом случае вы можете заполнить их по своему усмотрению. Узнать больше о `npm` конфигурации можно [тут](https://docs.npmjs.com/cli/config) и [тут](https://habrahabr.ru/post/243335/).\r\n\r\n> **Зачем вообще нужны пакетные менеджеры?**\r\n> Менеджеры пакетов упрощают установку и обновление зависимостей проекта, то есть сторонних библиотек, которые он использует: jQuery, Fotorama, все, что используется на твоем сайте и написано не тобой. Хождение по сайтам библиотек, скачивание и распаковка архивов, копирование файлов в проект — все это заменяется парой команд в терминале.\r\n> У многих языков программирования есть стандартные менеджеры пакетов, которыми разработчики пользуются для установки всех библиотек: gem у Ruby, pip у Python и другие.\r\n\r\nДля того чтобы установить какой-нибудь пакет/модуль/плагин/библиотеку/фреймворк/whatever нужна лишь одна команда `npm`:\r\n\r\n```bash\r\n$ npm install module_name library_name ...\r\n``` \r\n\r\n`npm` скачает заархивированный модуль со всеми его зависимостями, распакует и установит в автогенерируемую под-директорию вашего проекта `node_modules`.\r\n\r\nКоманда `npm install` имеет ряд важных флагов, среди которых `-g`, `-S`, `-D`:\r\n\r\nФлаг `-g` сообщает  `npm`, что данные модуль/модули нужно установить **глобально**, что означает что они в дальнейшем будут доступны из любого места на вашем ПК. Чаще всего данный флаг используется для установки CLI-[инструментов](https://habrahabr.ru/post/126605/)\r\n\r\nФлаги `-S` и `-D` сообщают `npm` о том, что после установки пакетов нужно записать их в список зависимостей `package.json`. Разница между ними в том, что `-S` используется для сохранения пакета как основной зависимости т.е. такой, которая  важна для функционала вашего проекта а `-D` для сохранения пакета как зависимость которая полезна для разработки, но никак не влияет на работоспособность приложения, это могут быть: сборщики, разного рода компиляторы, инструменты тестирования и др.\r\n\r\nФлаг `-S` является алиасом для флага `--save`, и `-D` для `--save-dev`, и в конце-концов у самой команды `install` есть сокращенный вариант `i`, т.е. и такая запись будет правильной:\r\n\r\n```bash\r\n$ npm i -S some-module\r\n```  \r\n\r\nИ такая:\r\n\r\n```bash\r\n$ npm install --save some-module\r\n```\r\n\r\nТеперь соберем в одну кучу весь список зависимостей:\r\n\r\n - `async`\r\n - `express`\r\n - `express-handlebars`\r\n - `mongoose`\r\n \r\nИ установим их.\r\n\r\n### Конфигурирование MongoDB для проекта\r\n**Mongo** - эта СУБД из разряда **No-SQL** баз данных - она хранит данные не  в виде классических SQL таблиц, таких как в PostgreSQL, MySQL  или MSSQL. Взамен все данные в MongoDB представляются в виде [`JSON`](https://ru.wikipedia.org/wiki/JSON)-объектов и хранятся в виде [`BSON`](https://ru.wikipedia.org/wiki/BSON) - формата бинарного представления простейших структур данных JavaScript. Так как это не старые-добрые таблички в SQL, то и композиция данных тут другая: в то время, как типичная база данных SQL состоит из таблиц -  база данных MongoDB состоит из **коллекций**; вместо строк в таблицах SQL коллекция MongoDB содержит **документы**, а вместо колонок строки в SQL таблице документ принимает вид JS объекта. Полями **документа** по стандарту `JSON` могут быть строки, числа, массивы и объекты.\r\n\r\nДля того, чтобы мы могли работать с базой данных, нужно наладить соединение с ней. Если вы правильно установили **MongoDB**, то, для начала, нужно запустить [*демон*](https://en.wikipedia.org/wiki/Daemon_(computing)) [`mongod`](https://docs.mongodb.com/manual/reference/program/mongod.exe/). Находится он, обычно, в директории `${MongoDB src}/Server/${MongoDB version}/bin/`\r\n\r\nДля удобства вы можете создать директорию `.data` в корне своего проекта и исполняемый файл `mongod.bat` для `Windows` или `mongod.sh` с правами доступа `a+x` для `UNIX`-систем с таким содержанием:\r\n\r\n```bash\r\n${path_to_mongod} --dbpath=.data\r\n```\r\n\r\nГде `${path_to_mongod}` - путь до исполняемого файла `mongod` на вешей системе.\r\n\r\nДля запуска в среде Cloud9:\r\n\r\n```bash\r\n$ sudo apt-get install -y mongodb-org\r\n$ mkdir .data\r\n$ echo 'mongod --bind_ip=$IP --dbpath=.data --nojournal --rest \"$@\"' > mongod\r\n$ chmod a+x mongod\r\n```\r\n\r\nИ запустить вызовом нашего простого скрипта:\r\n\r\n```bash\r\n$ ./mongod\r\n```\r\n\r\n![UNIX](https://snag.gy/lOLYVe.jpg)\r\n\r\nВ среде Cloud9:\r\n\r\n![enter image description here](https://snag.gy/FkiU94.jpg)\r\n\r\n![enter image description here](https://snag.gy/BJgNEn.jpg)\r\n\r\nДля работы с **MongoDB** напрямую, можно запустить хост `mongo` в директории `${MongoDB src}/Server/${MongoDB version}/bin/`. \r\n\r\nЕсли хост запущен успешно, вы увидите:\r\n\r\n```bash\r\nMongoDB shell version: 3.2.9\r\nconnecting to: test\r\n>\r\n```\r\n\r\nКомандой `show dbs` хост выведет все доступные базы данных\r\n\r\n![enter image description here](https://snag.gy/A460nb.jpg)\r\n\r\nДля вывода доступных команд можно ввести\r\n\r\n```bash\r\n> db.help()\r\n```\r\n\r\n![enter image description here](https://snag.gy/2lZAMJ.jpg)\r\n\r\n## План реализации\r\nБазовый принцип работы RESTful API - есть набор роутов(маршрутов), по которым проходит пользователь, и в зависимости от конкретного роута реагирует назначенный контроллер модели.\r\n\r\nЧто можно понимать под \"реагированием\"? Известно, что есть несколько основных типов `http`-запросов: `GET`, `POST`, `PUT`, `DELETE`. Так, в зависимости от требуемого функционала контроллер реагирует на запрос и возвращает определенный набор данных(ответ)\r\n\r\nВ нашем случае, контроллеры будут реагировать только на `GET`-запросы т.к. требуется только получать информацию.\r\n\r\nРоут - это, определенный маршрут с параметрами и аргументами который строится над `url` сайта или приложения:\r\n\r\n```http\r\nhttps://www.theguardian.com/world/europe-news\r\n```\r\n\r\nРазберем данный адрес, и посмотрим, что тут является роутом, а что нет:\r\n\r\n```bash\r\nhttps://\t\t\t# протокол\r\ntheguardian.com \t# домен\r\n/world/europe-news\t# роут\r\n``` \r\n\r\nВ данном `URL` мы запросим под-категорию новостей `/europe-news` категории `/world` новостного сайта `guardian.com` по защищенному протоколу подключения `https://`\r\n\r\nПо функционалу, наш сервис будет схож с [The Guardian](https://www.theguardian.com/international), а именно хранить и отображать данные, полученные из `http://content.guardianapis.com`\r\n\r\nТеперь можно определить основные роуты(маршруты) для нашего сервиса:\r\n\r\n```bash\r\n/\t\t\t\t\t# index route\r\n/news/\t\t\t\t# news section root\r\n/news?id\t\t\t# get a single article\r\n/news?sections\t\t# get multiple sections\r\n/news/latest\t\t# latest news section\r\n/news:section\t\t# get a section articles \r\n``` \r\n\r\nВ начале разработки серверной части нам нужно подключить зависимости и настроить наш сервер, как отправную точку для дальнейшей разработки и функционирования сервиса.\r\n\r\nЗатем нужно описать модель данных, контроллер модели и роутер, настроить отображение данных.\r\n\r\n## Немного серверного кода\r\n1. Создание конфигурационного файла\r\n2. `app.js` как стартовая точка сервера\r\n3. Получение данных из `content.guardian.api`\r\n4. Модель данных\r\n5. Контроллеры\r\n6. Роуты\r\n7. Последние приготовления и запуск\r\n\r\n### Создание конфигурационного файла\r\nСоздадим файл `config.js` в директории `etc`. \r\nВ этом файле мы опишем константы, которые будут использоватся в дальнейшем при разработке и работе сервиса:\r\n\r\n```js\r\nvar config = {\r\n\tSERVER: {\r\n\t\tHOST: process.env.IP || 'localhost',\r\n\t\tPORT: process.env.PORT || 3000\r\n\t},\r\n\tDATABASE: {\r\n\t\tHOST: process.env.IP || 'localhost',\r\n\t\tNAME: 'newsdb' \r\n\t},\r\n\tAPI: {\r\n\t\tKEY: '...',\r\n\t\tSECTIONS: ['world', 'sport', 'football', 'commentisfree', 'culture', 'business', 'lifeandstyle', 'fashion', 'environment', 'technology', 'travel'],\r\n\t\tFIELDS: ['headline', 'trailText', 'byline', 'main', 'body', 'shortUrl', 'thumbnail']\r\n\t}\r\n}\r\n\r\nmodule.exports = config;\r\n```\r\n\r\nДля обьекта `API`, в частности для его поля `KEY` нужно [зарегестрировать свой ключ доступа](https://bonobo.capi.gutools.co.uk/register/developer).\r\n\r\nТак же, именно последняя строка `module.exports = config` позволяет нам подключать данный файл в другие модули нашего приложения\r\n\r\n### `app.js` как стартовая точка сервера\r\nСоздадим файл `app.js` в директории `server`. Подключим установленные ранее зависимости и наш ранее созданный  конфиг:\r\n\r\n```js\r\nvar express      = require('express'),\r\n    path         = require('path'),\r\n    handlebars   = require('express-handlebars'),\r\n    mongoose     = require('mongoose'),\r\n    config       = require('../etc/config');\r\n```\r\n\r\nВы можете заметить тут модуль `path` о котором раньше ничего не говорилось. Модуль [`path`](https://nodejs.org/api/path.html) является встроенным модулем Node.js и содержит утилиты для работы с путями.\r\n\r\nДалее инициализируем наше приложение вызовом ф-ции `express`:\r\n\r\n```js\r\nvar app = express();\r\n```\r\n\r\nИ запустим сервер простым вызовом метода `express` **`listen`**:\r\n\r\n```js\r\napp.listen(config.SERVER.PORT, config.SERVER.HOST, () =>\r\n    console.log(`\\nMagic happens on port ${config.SERVER.PORT}`));\r\n```\r\n\r\nЧто здесь происходит: мы говорим нашему `express`-приложению прослушивать определенный нами `PORT` на определенном `HOST` и использовать данный адрес как отправную точку нашего приложения. Например:\r\n\r\n```js\r\n// http://${HOST}:${PORT}\r\nhttp://localhost:3000/\r\n``` \r\n\r\n**Внимание** - дальнейшие изменения нужно будет вносить после инициализации переменной `app` и до запуска сервера `app.listen()`!\r\n\r\nЧтобы проверить, что все мы сделали правильно, сервер нужно запустить простой командой:\r\n\r\n```bash\r\n$ node server/app\r\n``` \r\n\r\n![enter image description here](https://snag.gy/b1DifB.jpg)\r\n\r\n### Получение данных из `content.guardian.api`\r\nДля того чтобы получить данные из **Guardian API** нам нужно сделать `GET`-запрос к **Guardian** RESTful API. Для этого  мы будем использовать стандартную реализацию `http` в **Node.js** и нашь уже подготовленный конфиг. Посмотреть и потрогать **Guardian API** можно [здесь](http://open-platform.theguardian.com/explore/).\r\n\r\nСоздадим файл `guardian-get.js` в директории `server/lib` и подключим все что нам потребуется, а именно `http` и `https` модули и нашь конфиг:\r\n\r\n```js\r\nvar http = require('http'),\r\n\thttps  = require('https'),\r\n\tconfig = require('../../etc/config');\r\n```\r\n\r\nДалее определим главную функцию:\r\n\r\n```js\r\nvar httpGET = (options, done, err) => { }\r\n``` \r\n\r\nРасшифрую аргументы функции:\r\n\r\n - `options` - обьект конфигурации запроса, будет рассмотрен далее\r\n - `done` - callback-функция, которая будет вызвана при успешном окончании запроса\r\n - `err` - callback-функция - обработчик ошибок \r\n\r\nПринцип работы функции будет таким:\r\n\r\n - Определить подключение: защищенное / незащищенное\r\n - Запустить асинхронное выполнение запроса\r\n - Собирать данные по мере их поступления\r\n - По окончании запроса вызвать callback-функцию `done`\r\n - При возникновении ошибки вызвать обработчик\r\n\r\nПриступим к реализации:\r\n\r\n```js\r\nvar httpGET = (options, done, err) => {\r\n\t// Определить подключение: защищенное / незащищенное\r\n\tvar server = options.port === 443 ? https : http;\r\n\t// Запустить асинхронное выполнение запроса\r\n\tvar req = server.request(options, res => {\r\n\t\t// Строка, в которую мы будем собирать входящие данные\r\n\t\tlet output = '';\r\n\t\t// Кодировка, в которой мы хотим получить данные\r\n\t\tres.setEncoding('utf8');\r\n\t\t// Собирать данные по мере их поступления\r\n\t\tres.on('data', chunk => output += chunk);\r\n\t\t// По окончании запроса вызвать callback \"done\" и передать в него полученные данные\r\n\t\tres.on('end', () => done(JSON.parse(output)));\r\n\t\t// Выведем состояние запроса\r\n\t\tconsole.log(`Request status: ${options.host}:${res.statusCode}`);\r\n\t});\r\n\r\n\t// При возникновении ошибки вызвать обработчик\r\n\treq.on('error', err);\r\n\t// Закрыть подключение\r\n\treq.end();\r\n}\r\n```\r\n\r\nНет, я не забыл описать тот загадочный объект `options`. Этот объект описывает, или другими словами настраивает наш `http`-запрос. Он должен содержать такие поля: `host`, `port`, `path`, `method`, `headers`\r\n\r\n- `host`: базовый адрес, к которому мы обращаемся или URI определяющий путь к запрашиваемому документу\r\n- `port`: порт подключения\r\n- `path`: здесь мы описываем запрос к `host`'у\r\n- `method`:  [вид запроса](https://ru.wikipedia.org/wiki/HTTP#.D0.9C.D0.B5.D1.82.D0.BE.D0.B4.D1.8B) - `GET`, `POST`, `PUT`, `DELETE`\r\n- `headers`:  строки HTTP-сообщения, содержащие разделённую двоеточием пару параметр-значение\r\n\r\nОписывать объект `options` мы будем при вызове нашей функции `httpGET` из анонимной функции-обёртки:\r\n\r\n```js\r\nmodule.exports = (query, done, err) => {\r\n\t// Шаблон запроса к The Guardian\r\n    var queryTemplate = `/search?show-fields=${config.API.FIELDS.join(',')}&api-key=${config.API.KEY}&${query}`;\r\n    var requestOptions = {\r\n        host: 'content.guardianapis.com',\t// API-endpoint\r\n        port: 443,\r\n        path: queryTemplate,\r\n        method: 'GET',\r\n        headers: {\r\n            'Content-Type': 'application/json'\r\n        }\r\n    };\r\n\r\n    httpGET(requestOptions, done, err);\r\n};\r\n```\r\n\r\nПротестировать этот скрипт можно с помощью [Node REPL](https://nodejs.org/api/repl.html):\r\n\r\n```bash\r\n$ node\r\n> 'use strict'\r\n> var get = require('./server/lib/guardian-get');\r\n> get('', console.log.bind(console), console.log.bind(console));\r\n```\r\n\r\nЕсли вы все правильно ввели, то статус запроса должен быть таким:\r\n\r\n```bash\r\n> Request status: content.guardianapis.com:200\r\n```\r\n\r\nИ через некоторое время вы получите ответ от  `content.guardianapis.com`:\r\n\r\n```json\r\n{\r\n    \"response\":{\r\n        \"currentPage\":1,\r\n        \"pageSize\":10,\r\n        \"pages\":189508,\r\n        \"total\":1895080,\r\n        \"userTier\":\"developer\",\r\n        \"startIndex\":1,\r\n        \"results\":[\r\n            [ \"Object\" ],\r\n            [ \"Object\" ],\r\n            [ \"Object\" ],\r\n            [ \"Object\" ],\r\n            [ \"Object\" ],\r\n            [ \"Object\" ],\r\n            [ \"Object\" ],\r\n            [ \"Object\" ],\r\n            [ \"Object\" ],\r\n            [ \"Object\" ]\r\n        ],\r\n        \"status\":\"ok\",\r\n        \"orderBy\":\"newest\"\r\n    }\r\n}\r\n```\r\n\r\n![enter image description here](https://snag.gy/iGsNVR.jpg)\r\n\r\n### Модель данных\r\nХотите пример структуры данных при использовании **Mongoose** с моими кривыми стрелочками?\r\n\r\n![enter image description here](http://i66.tinypic.com/4qo35x.jpg)\r\n\r\n**Моделью** в нашем проекте будет считаться некоторая сущность-информационная единица, которая будет хранится в базе данных, а именно **MongoDB**, и которая будет иметь поведение, или другими словами содержать в себе несколько вспомогательных методов для работы с БД. Определять модель данных мы будем с помощью библиотеки `mongoose`. **Mongoose** будет оборачивать наши данные в специальную [схему данных](http://mongoosejs.com/docs/guide.html) для дальнейшего их использования нашим сервисом. \r\n\r\nТеперь, когда *демон* успешно **запущен**, нам нужно добавить всего одну строчку в `app.js`:\r\n\r\n```js\r\nmongoose.connect(\r\n\t`mongodb://${config.DATABASE.HOST}/${config.DATABASE.NAME}`, \r\n\terr => {\r\n\t\tif (err) throw err;\r\n\t\tconsole.log(\"Magic connected to database\");\r\n\t});\r\n```\r\n\r\nПервым аргумент - `url` подключения к БД, второй - `callback` который уведомит нас об ошибке или успешном выполении\r\n\r\n![enter image description here](https://snag.gy/m9tnzS.jpg)\r\n\r\n#### Схема данных\r\n\r\nПришло время занятся схемой нашей будущей модели. Схема или `Mongoose.Schema` позволяет нам функционально и семантически разметить тип хранимых нами в БД данных. Процесс описания схемы чем-то схож с созданием новой таблицы в SQL-подобных СУбД - нам нужно описать название полей объекта, их тип и другие параметры. Но это только аналогия, документы **MongoDB** в лице **Mongoose**-схем штука порядком мощнее, но это вы и сами в дальнейшем увидите. А сейчас приступим к схеме. Создадим файл `guardian-content.model.js` в директории `server/models` с таким содержимым:\r\n\r\n```js\r\n\"use strict\";\r\n\r\nvar mongoose = require('mongoose');\r\n\r\nvar GuardianContentSchema = new mongoose.Schema({\r\n\tid: {\r\n\t\ttype: String,\r\n\t\tindex: true\r\n\t},\r\n\tsectionId: String,\r\n\ttype: String,\r\n\twebPublicationDate: Date,\r\n\ttitle: String,\r\n\twebUrl: String,\r\n\tfields: {\r\n\t\theadline: String,\r\n\t\ttrailText: String,\r\n\t\tbyline: String,\r\n\t\tmain: String,\r\n\t\tbody: String\r\n\t}\r\n});\r\n```\r\n\r\nВнимание - тип поля `fields` - объект, а его значением является вложенная схема. Да - так тоже можно, это же `JSON`. Это же `JS` в конце-концов - у нас тут все можно ;)\r\n\r\nМы можем расширить определение полей немногим количеством опциональных параметров, например: \r\n\r\n```js\r\nvar GuardianContentSchema = new mongoose.Schema({\r\n\tid: {\r\n\t\ttype: String,\r\n\t\tindex: true\r\n\t},\r\n\tsectionId: {\r\n\t\ttype: String,\r\n\t\trequired: true\r\n\t},\r\n\ttype: {\r\n\t\ttype: String,\r\n\t\tdefault: 'article'\r\n\t},\r\n\twebPublicationDate: {\r\n\t\ttype: Date,\r\n\t\tdefault: Date.now\r\n\t},\r\n\ttitle: {\r\n\t\ttype: String,\r\n\t\trequired: true,\r\n\t\ttrim: true\r\n\t},\r\n\twebUrl: {\r\n\t\ttype: String,\r\n\t\trequired: true\r\n\t}\r\n}\r\n```\r\n\r\nЗдесь:\r\n\r\n - `index` указывает, что по этому полю документы будут индексироваться\r\n - `required` задает поле как обязательное для заполнения\r\n - `default` - значение по умолчанию\r\n - `trim` - имплементация все того-же [`String.prototype.trim()`](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/String/Trim) \r\n\r\nНо это был демонстрационный пример, продолжать мы будем с первой, лаконичной версией.\r\n\r\nС описанием схемы/модели/прототипа данных мы закончим, передав в конструктор `Mongoose.Schema()` дополнительный параметр опций. Добавим данный сниппет кода перед определением схемы:\r\n\r\n```js\r\nvar GuardianContentSchemaOptions = {\r\n\ttimestamps: {},\r\n\tsafe: true\r\n}\r\n```\r\n\r\nДанные опции позволяют присваивать даты создания и изменения конкретной модели. Передадим их в конструктор:\r\n\r\n```js\r\nvar GuardianContentSchema = new mongoose.Schema({\r\n\t// Schema...\r\n}, GuardianContentSchemaOptions);\r\n``` \r\n\r\nВот теперь можно сказать, что со схемой данных мы закончили. Теперь нужно определить модель данных:\r\n\r\n```js\r\nvar GuardianContentModel = mongoose.model(\"news\", GuardianContentSchema);\r\n\r\nmodule.exports = GuardianContentModel;\r\n```\r\n\r\nЗдесь мы определяем `mongoose`-модель с помощью конструктора `mongoose.model`, который принимает два параметра - название модели и схему данных. Далее, при создании первого объекта модели в нашей базе данных автоматически создастся коллекция с с именем модели во множественном числе, т.е. в нашем случае это будет так и останеться - \"news\". Но если бы мы определяли модель под названием \"apple\" или \"bill\" то создались бы коллекции под названием \"apples\" и \"bills\" соответственно.  \r\n\r\nТеперь можем проверить работоспособность нашей модели\r\n\r\n```bash\r\n$ node\r\n> var mongoose = require('mongoose');\r\n> var Model = require('./server/models/guardian-content-model.js');\r\n> new Model({id: \"sport/article\", sectionId: \"sport\", type: \"article\", webPublicationDate: Date.now(), title: \"New section\", webUrl: \"http://google.com\", fields: {}});\r\n```\r\n\r\n![enter image description here](https://snag.gy/vz86xl.jpg)\r\n\r\n#### Поведение модели и вспомогательные методы\r\n**Mongoose** определяет несколько типов  функций для манипуляций данными:\r\n\r\n - Встроенные методы\r\n - Пользовательские методы\r\n - Статические методы\r\n - Вспомогательные запросы\r\n\r\nМы будем использовать несколько встроенных методов библиотеки **Mongoose**:\r\n\r\n - `find()` и `findOne()`\r\n - `sort()`\r\n - `limit()`\r\n - `save()`\r\n\r\nДля ф-ций `find()` и `findOne()` аргументом является объект-конфиг поиска. Пример для нашей модели данных:\r\n\r\n```js\r\n// Получить статьи только этого года\r\nvar query = { \r\n\ttype: \"article\",\r\n\twebPublicationDate: new Date().getFullYear() \r\n} \r\n\r\nModel.find(query)\r\n\t.exec(console.log.bind(console));\r\n```\r\n\r\nМы будем определять свои вспомогательные функции запросов. Об остальных типах вы можете узнать из [документации](http://mongoosejs.com/docs/guide.html)\r\n\r\nНам понадобятся четыре ф-ции:\r\n\r\n - `byContentId`\r\n - `latest`\r\n - `bySections`\r\n - `bySection`\r\n\r\nСинтаксис использования вспомогательных ф-ций будет примерно таков:\r\n\r\n```js\r\nModel.find()\r\n\t.byContentId(\"i'm an id of section\")\r\n\t.exec(callback);\r\n```\r\n\r\nВ ф-цию `exec` передается `callback` с двумя аргументами - объект ошибки и объект найденных данных:\r\n\r\n```js\r\nlet searchCallback = (err, data) => {\r\n\tif (err) {\r\n\t\tthrow err;\r\n\t} else {\r\n\t\t// Do something with data\r\n\t}\r\n}\r\n```\r\n\r\nИтак, приступим к реализации. Для начала изобразим ф-цию `byContentId`:\r\n\r\n```js\r\nGuardianContentSchema.query.byContentId = function(id) {\r\n\treturn this.findOne({ \r\n\t\tid: id\r\n\t});\r\n};\r\n```\r\n\r\nЗдесь метод `Model.findOne` является встроенным, и из названия можно догадаться, что возвращает он только один экземпляр документа с переданными в него опциями.  \r\n\r\n```js\r\nGuardianContentSchema.query.latest = function() {\r\n\treturn this.find()\r\n\t\t.sort('-date')\r\n\t\t.limit(10);\r\n};\r\n```\r\n\r\nМетод вернет последние документы по дате отсортированные по убыванию\r\n\r\n```js\r\nGuardianContentSchema.query.bySections = function(sections) {\r\n\treturn this.find({ \r\n\t\t\tsectionId: { \r\n\t\t\t\t$in: sections.split(',') \r\n\t\t\t}\r\n\t\t})\r\n\t\t.limit(20);\r\n};\r\n```\r\n\r\nДанный метод вернет документы по секциям, определенным в массиве `sections`. \r\nИ наконец, получение статей по определенной секции:\r\n\r\n```js\r\nGuardianContentSchema.query.bySection = function(section) {\r\n\treturn this.find({ \r\n\t\t\tsectionId: section \r\n\t\t})\r\n\t\t.limit(10);\r\n};\r\n```\r\n\r\n**Внимание**, определить данные методы нужно **перед** определением модели.\r\n\r\nПосле определения модели, добавим ей еще один метод - `spread`, который упростит нашу жизнь в будущем:\r\n\r\n```js\r\nGuardianContentModel.spread = (items, done) =>\r\n\titems.forEach(item =>\r\n\t\tnew GuardianContentModel(item)\r\n\t\t\t.save(done));\r\n```\r\n\r\nОн сохраняет множество/массив элементов и принимает два аргумента:\r\n- `items` - массив `JS` объектов, который нужно сохранить\r\n- `done` - ф-ция которая выполнится после сохранении **каждого** документа  \r\n\r\nИ того, с схемой и моделью данных мы закончили:\r\n\r\n```js\r\n// server/models/guardian-content-model.js\r\n\"use strict\";\r\n\r\nvar mongoose = require('mongoose');\r\n\r\nvar GuardianContentSchemaOptions = {\r\n\ttimestamps: {},\r\n\tsafe: true\r\n}\r\n\r\nvar GuardianContentSchema = new mongoose.Schema({\r\n\tid: {\r\n\t\ttype: String,\r\n\t\tindex: true\r\n\t},\r\n\tsectionId: String,\r\n\ttype: String,\r\n\twebPublicationDate: Date,\r\n\ttitle: String,\r\n\twebUrl: String,\r\n\tfields: {\r\n\t\theadline: String,\r\n\t\ttrailText: String,\r\n\t\tbyline: String,\r\n\t\tmain: String,\r\n\t\tbody: String\r\n\t}\r\n}, GuardianContentSchemaOptions);\r\n\r\nGuardianContentSchema.query.byContentId = function(id) {\r\n\treturn this.findOne({ \r\n\t\tid: id \r\n\t});\r\n};\r\n\r\nGuardianContentSchema.query.latest = function() {\r\n\treturn this.find()\r\n\t\t.sort('-date')\r\n\t\t.limit(10);\r\n};\r\n\r\nGuardianContentSchema.query.ofSections = function(sections) {\r\n\treturn this.find({ \r\n\t\t\tsectionId: { \r\n\t\t\t\t$in: sections.split(',') \r\n\t\t\t}\r\n\t\t})\r\n\t\t.limit(20);\r\n};\r\n\r\nGuardianContentSchema.query.ofSection = function(section) {\r\n\treturn this.find({ \r\n\t\t\tsectionId: section \r\n\t\t})\r\n\t\t.limit(10);\r\n};\r\n\r\nvar GuardianContentModel = mongoose.model(\"news\", GuardianContentSchema);\r\n\r\nGuardianContentModel.spread = (items, done) =>\r\n\titems.forEach(item =>\r\n\t\tnew GuardianContentModel(item)\r\n\t\t\t.save(done));\r\n\r\nmodule.exports = GuardianContentModel;\r\n```\r\n\r\n### Контроллеры\r\n\r\n#### Index controller\r\n\r\nIndex-контроллер будет отвечать за переход к корню сайта, т.е. к роуту `/`. По функционалу, `index`-контроллер обычно следит за состоянием авторизации пользователя, который проходит по роута, кеширование или инициализацию БД.\r\n\r\nВ нашем случае, `index`-контроллер будет иметь только один метод `reserve`, который будет обновлять БД актуальным контентом из **Guardian API**.\r\n\r\nСоздадим файл `index.controller.js` в директории `server/controllers` и первым делом подключим зависимости. Нам понадобятся модуль `async`, наш конфигурационный файл, `http-get`-функция и наша модель данных:\r\n\r\n```js\r\n\"use strict\";\r\n\r\nvar async       = require('async');\r\nvar config      = require('../../etc/config');\r\nvar guardianGet = require('../lib/guardian-get');\r\nvar Model       = require('../models/guardian-content.model');\r\n```\r\n\r\nТ.к. метод в данном контроллере будет только один, то мы можем определить его сразу в объект `module.exports`:\r\n\r\n```js\r\nmodule.exports.reserve = () => {\r\n\t// Whatever...\r\n};\r\n```\r\n\r\nИтак, что должен делать наш метод? Нам нужно получить данные(статьи, посты и т.д.) по каждому новостному-разделу сайта `The Guardian` и сохранить их в БД. Но как нам это сделать?\r\n\r\nСамое очевидное, что первое приходит на ум - это пройтись по массиву названий секций, получить каждую по очереди и сохранить в БД. Так и сделаем:\r\n\r\n```js\r\nmodule.exports.reserve = () =>\r\n\tconfig.API.SECTIONS.forEach(section =>\r\n\t\tguardianGet(`section=${ section }`, (data, err) => {\r\n\t\t\tif (err) throw err;\r\n\t\t\tModel.spread(data.response.results, (err, doc) => \r\n\t\t\t\tconsole.log(err ? \r\n\t\t\t\t\terr : `[${doc.id}] saved to ${config.DB.NAME}`))\r\n\t\t}));\r\n```\r\n\r\nНу вот, неплохой-такой спагетти-код. Но тут ничего сложного пока нет. Мы проходим итератором по массиву разделов и для каждого формируем `GET`-запрос передавая первым аргументом в ф-цию `guardianGet` строку запроса. По окончании запроса, т.е. получении данных по каждому разделу сохраняем множество статей в БД с помощью ф-ции `spread`. Но этот весь этот код, включая ф-цию `Model.spread`, будет работать **синхронно**, т.е. пока, на данный момент при срабатывании данного контроллера будем **синхронно** получать 110 статей за раз. \r\n\r\nДопустим, нашим приложением будет пользоваться только один пользователь и обрабатывать 100-300 статей в сутки не такая и большая нагрузка, но если таких пользователей будет 300 или 3000? Посчитать разницу не сложно, а сервер нашего приложения  будет только **один**. \r\n\r\nТ.е. ситуация: пользователь `А` заходит на наш сайт, контроллер обновляет базу данных **синхронно**. Примерно в тот-же момент наш сайт посещает еще один пользователь `B` и на его сессию контроллер срабатывает так-же. Только один момент - контроллер ждет, пока обновление БД закончится после посещения сайта пользователем `A`, и только потом начнет получать и обрабатывать данные для сессии пользователя `B`. А если вернутся в начало, и если, примерно в тот-же момент, что и пользователь `A` на наш сайт заходят еще 50? Все - приложение для клиентов повиснет, и никто из оставшихся 49 ждущих пользователей не будет ждать загрузки контента, а может и пользователь `А` не будет. \r\n\r\nВ таком случае нам нужно как-то выходить из ситуации, а именно с помощью **асинхронных** операций. Мы можем изменить архитектуру нашего сервера таким образом, что определенное множество операций не будут блокировать друг-друга а выполняться *независимо*.\r\n\r\nНачнем с метода `spread` нашей модели. На данный момент он выглядит так:\r\n\r\n```js\r\nGuardianContentModel.spread = (items, done) =>\r\n\titems.forEach(item =>\r\n\t\tnew GuardianContentModel(item)\r\n\t\t\t.save(done));\r\n```\r\n\r\nСинхронность операций в этом методе выражается прямо в его алгоритме:\r\n\r\n 1. Береться `n` елемент\r\n 2. На его основе инициализируется модель\r\n 3. Модель сохраняется в базу данных\r\n\r\nЭто привычный нам поток выполнения инструкции любой стандартной программы, но проблемы начинаются с первых строк: в то время, как проводятся манипуляции над `n` элементом массива, `n+1` элемент ожидает окончания выполнения операций над элементом `n`. В данном случае это не кажется столь критичным, так как и **JS**, и **MongoDB** довольно быстры. Ну, хорошо когда с производительностью ваших инструментов проблем нет, но данная проблема содержится не в инструментах, а в потоке данных, точнее в их количестве.\r\n\r\n> Чем больше данных, тем больше время их обработки!\r\n\r\nМы можем немного расширить реализацию уже существующего алгоритма с помощью библиотеки `async`. Не забудьте **подключить** данную библиотеку!\r\n\r\n```js\r\nGuardianContentModel.spread = (items, done) => {\r\n\tvar tasks = items.map(item => function task() {\r\n\t\treturn new GuardianContentModel(item).save(done);\r\n\t});\r\n\r\n\tasync.parallel(tasks, \r\n\t\t() => console.log('Data saved successfuly!'));\r\n};\r\n``` \r\n\r\nЗдесь мы формируем массив задач на каждую операцию инициализации модели, т.е. в конце-концов мы получим массив синхронных функций которые нужно будет запустить асинхронно. Во время  Запускать мы их будем с помощью метода `parallel`. Вот и все, теперь данный метод будет запускаться асинхронно. \r\n\r\nТак же сделаем рефакторинг нашего `index`-контроллера:\r\n\r\n```js\r\nmodule.exports.reserve = () => {\r\n\tvar saveToDatabase = (data, err) =>\r\n\t\tModel.spread(data.response.results, (err, doc) => \r\n\t\t\tconsole.log(err ? err : `[${doc.id}] saved to ${config.DB.NAME}`));\r\n\r\n\tvar asyncTasks = config.API.SECTIONS.map(section => \r\n\t\tfunction task() {\r\n\t\t\treturn guardianGet(`section=${ section }`, saveToDatabase);\r\n\t\t});\r\n\t\r\n\tasync.parallel(asyncTasks, () => \r\n\t\tconsole.log('Data reserved successfuly'));\r\n};\r\n```\r\n\r\n#### News controller\r\n\r\nЭтот контроллер будет контроллером модели. Он будет той самой прослойкой между бизнес-логикой и данными нашего приложения.\r\n\r\nВ данном случае, нам нужны методы, которые будут в определенном случае обращаться к модели для получения данных:\r\n\r\n - `get` - будет отвечать за обработку определенной статьи или множества разделов\r\n - `getSection` - будет отвечать за получение статей из определенного раздела \r\n - `getLatest` - будет отвечать за получение свежих новостей\r\n\r\nКаждый из методов будет функцией вида:\r\n\r\n```js\r\nvar anotherMethod = (req, res) => {\r\n\t// Whatever\r\n}\r\n```\r\n\r\nТакие ф-ции являются неким *шаблоном* для работы с роутами `express`-фреймворка. В дальнейшем, когда мы будем связывать наши роутеры с нашими контроллерами, в аргументы методов будут передаваться специальные объекты [`Request`](http://expressjs.com/ru/4x/api.html#req) и [`Response`](http://expressjs.com/ru/4x/api.html#res).\r\n\r\nОбъект `Request` представляет `http`-запрос и имеет свойства присущие ему - строку запроса, тело запроса, заголовки и [т.д.](https://www.w3.org/Protocols/rfc2616/rfc2616-sec5.html)\r\n\r\nОбъект `Response` - инструмент отправки данных в `express`. Основные [методы](http://expressjs.com/ru/4x/api.html#res) которые мы будем использовать:  \r\n\r\n - `status` - отправляет клиенту статус его запроса\r\n - `json` - передает данные в формате `JSON`\r\n\r\nСоздадим файл `index.controller.js` в директории `server/controllers` и подключим нашу модель.\r\n\r\nМожно сразу вынести функцию-обработчик полученных данных из БД:\r\n\r\n```js\r\nvar handleData = (err, data, res) => {\r\n\tif (err) {\r\n\t\tres.status(404);\t// not found\r\n\t\tconsole.error(err);\r\n\t} else {\r\n\t\tres.status(200)\r\n\t\t\t.json(data);\t// ok/found\r\n\t}\r\n};\r\n``` \r\n\r\nДалее определим три вышеописанных метода данного контроллера:\r\n\r\n```js\r\nvar get = (req, res) => {\r\n\tif (req.query.id) {\r\n\t\tModel.find()\r\n\t\t\t.byContentId(req.query.id)\r\n\t\t\t.exec((err, data) =>\r\n\t\t\t\thandleData(err, data, res));\r\n\t} else {\r\n\t\tModel.find()\r\n\t\t\t.bySections(req.query.sections)\r\n\t\t\t.exec((err, data) =>\r\n\t\t\t\thandleData(err, data, res));\r\n\t}\r\n};\r\n\r\nvar getSection = (req, res) =>\r\n\tModel.find()\r\n\t\t.bySection(req.params.section)\r\n\t\t.exec((err, data) => \r\n\t\t\thandleData(err, data, res));\r\n\r\nvar getLatest = (req, res) =>\r\n\tModel.find()\r\n\t\t.latest()\r\n\t\t.exec((err, data) => \r\n\t\t\thandleData(err, data, res));\r\n``` \r\n\r\nИ осталось только экспортировать этот контроллер:\r\n\r\n```js\r\nmodule.exports = {\r\n\tget: get,\r\n\tgetSection: getSection,\r\n\tgetLatest: getLatest\r\n}\r\n```\r\n\r\n### Роуты\r\n\r\nОпределение роута в `express` выглядит таким образом:\r\n\r\n```js\r\nExpress.Router.method(path, handler);\r\n```\r\n\r\nНабор `handler`-ов мы определили ранее в виде контроллеров. В таком случае осталось привязать их у определенным маршрутам.\r\n\r\nСоздадим два файла в директории `server/routes/`: `index.route.js` и `news.route.js`\r\n\r\nДля `index.route.js` введем: \r\n\r\n```js\r\n\"use strict\";\r\n\r\nvar router     = require('express').Router();\r\nvar controller = require('../controllers/index.controller');\r\n\r\nrouter.get('/', (req, res) => {\r\n\tres.status(201)\t\t// 201 - Webpage created\r\n\t\t.render('home');\r\n\tcontroller.reserve();\r\n});\r\n\r\nmodule.exports = router;\r\n```\r\n\r\nЗдесь мы создаем экземпляр `express`-роутера, настраиваем с помощью него и `index`-контроллера маршрутизацию и экспортируем это все как модуль.\r\n\r\nДля `news.route.js` поступаем аналогично:\r\n\r\n```js\r\n\"use strict\";\r\n\r\nvar router     = require('express').Router();\r\nvar controller = require('../controllers/news.controller');\r\n\r\nrouter.get('/', controller.get);\r\nrouter.get('/latest', controller.getLatest);\r\nrouter.get('/:section', controller.getSection);\r\n\r\nmodule.exports = router;\r\n```\r\n\r\n### Последние приготовления и запуск\r\n\r\nТеперь осталось подключить наши роутеры в `app.js`. Подключать мы будем их перед вызовом метода `app.listen()`:\r\n\r\n```js\r\nvar routes = {\r\n\tindex: require('./routes/index.route'),\r\n\tnews:  require('./routes/news.route')\r\n}\r\n\r\napp.use('/', routes.index);\r\napp.use('/news/', routes.news);\r\n``` \r\n\r\nТеперь, откроем браузер и если введем в адресную строку временный адрес нашего приложения:\r\n\r\n```http\r\nhttp://localhost:3000/\r\n``` \r\n\r\nТо увидим, что ничего не происходит:\r\n\r\n![enter image description here](https://snag.gy/cREdte.jpg)\r\n\r\nНо нет, на самом деле происходит:\r\n\r\n![enter image description here](https://snag.gy/UuRxJE.jpg)\r\n\r\nПросто наш `index`-контроллер ничего не отправляет, а всего лишь выполняет одну, заложенную в него нами функцию - а именно получает данный извне и сохраняет их в БД. Вот и все.\r\n\r\nНо если мы перейдем по адресу:\r\n\r\n```http\r\nhttp://localhost:3000/news/latest\r\n```\r\n\r\nТо получим примерно такую `JSON`-ину:\r\n\r\n![enter image description here](https://snag.gy/SEoFwt.jpg)\r\n\r\nЕсли [отформатировать](https://jsonformatter.curiousconcept.com/) её, то увидим, что, насчет модели, все сходится:\r\n\r\n```json\r\n[\r\n    {\r\n        \"_id\": \"57fab3ef5fcb400a98c525ea\",\r\n        \"updatedAt\": \"2016-10-09T21:17:35.946Z\",\r\n        \"createdAt\": \"2016-10-09T21:17:35.946Z\",\r\n        \"webUrl\": \"https://www.theguardian.com/fashion/2016/oct/09/the-new-scent-of-a-woman-top-autumn-perfumes\",\r\n        \"webPublicationDate\": \"2016-10-09T05:00:02.000Z\",\r\n        \"id\": \"fashion/2016/oct/09/the-new-scent-of-a-woman-top-autumn-perfumes\",\r\n        \"sectionId\": \"fashion\",\r\n        \"type\": \"article\",\r\n        \"__v\": 0,\r\n        \"fields\":{\r\n            \"trailText\": \"Autumn has never smelled better, with wonderful new scents from established names and some lively newcomers, too, says Eva Wiseman\",\r\n            \"headline\": \"The new scent of a woman\",\r\n            \"body\": \"<!-- A lot of HTML -->\",\r\n            \"main\": \"<!-- Some HTML -->\",\r\n            \"byline\": \"Eva Wiseman\"\r\n        }\r\n    },\r\n    // Another items next...\r\n]\r\n```\r\n\r\nЕсли попробуем получить по `id`:\r\n\r\n![enter image description here](https://snag.gy/zk4esD.jpg)\r\n\r\nНесколько разделов\r\n\r\n![enter image description here](https://snag.gy/4TZJNp.jpg)\r\n\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}